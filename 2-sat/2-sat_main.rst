.. highlight:: cpp

2-SAT
=====

Теорию подготовил Никита Данилов. Вопросы по этой статье можно писать мне в телеграм: https://t.me/nik_danilov.

.. important::
 
    Если по каким-то причинам до текущего момента вы ещё не успели ознакомиться с алгоритмом поиска компонент сильной связности, настоятельно рекомендуется сделать это перед прочтением этой статьи: https://notes.algoprog.ru/dfs/04_3_topsort.html#badscc

`2-SAT` (2-satisfiability) - алгоритм для конструктивного распределения значений булевым переменным, для выполнения некоторых условий. Для быстрого понимания сути алгоритма, приведу пример задачи на него:

Дан граф на `n` вершинах, в нём проведены `m` рёбер. Нужно отметить несколько вершин так, чтобы на конце каждого ребра было хотя бы по одной отмеченной вершине, и чтобы не было двух отмеченных вершин, номера которых различаются на 1.

Условия, которые мы должны соблюсти при отметке этих вершин можно переформулировать так:

1. Если отмечена вершина с номером `x`, то не отмечены вершины `x - 1` и `x + 1`.

2. Если не отмечена вершина с номером `x`, и есть ребро между вершинами `x` и `y`, то вершина `y` отмечена.

Тогда давайте сделаем массив `mark` длины n, в котором `mark[i]` будет `true` если вершина `i` отмечена, и `false` иначе.

Ещё раз переформулируем те же условия:

1. Если `mark[x] == true`, то `mark[x - 1] = false` и `mark[x + 1] = false`.

2. Если есть ребро между вершинами `x` и `y`, `mark[x] == true` или `mark[y] = true`.

То есть теперь наша задача в том, чтобы распределить в массиве значения true и false переменным, так чтобы выполнялись некоторые условия. Это мы будем делать при помощи 2-SAT.

Алгоритм
________

Представим (mark[i] == true ИЛИ mark[j] == true) как:

((ЕСЛИ mark[i] == false ТО mark[j] == true) И (ЕСЛИ mark[j] == false ТО mark[i] == true))

Так как если на одном конце вершина не отмечена, на другом должна быть отмечена.

Тогда если сделать граф на 2n вершинах, где каждая вершина будет являтся возможным значением каждой переменной массива mark (то есть вершины mаrk[i] == true и mаrk[i] == false для i от 1 до n), тогда все взаимосвязи можно будет описать как ориентированые рёбра в этом графе (по 2 ребра на каждое условие ИЛИ).

Ребра нашего графа работают так: если какая-то вершина "истинна", то должны быть "истинны" все вершины, куда из нее выходят ребра (т.к. каждое ребро соответствует логическому условию "если - то".) Поэтому если мы помечаем как истинную какую-то вершину, то должны пометить все достижимые из нее.

Нас не устраивает только конструкция, при которой из mаrk[i] == true достижимо mаrk[i] == false или наоборот, так как тогда мы не можем присвоить mark[i] какое либо значение. 

То есть когда вершины, которые им соответствуют, лежат в одной компоненте сильной связности в указанном графе. Это можно проверить, сделав конденсацию графа.

Если таких противоречий нет, сделаем топологическую сортировку графа, та из вершин а и НЕ а, которая окажется самой левой (при условии что рёбра в топологической сортировке между разными компонентами идут справа-налево), и есть нужное значение.

Пример кода:

::

	vector<vector<long long>> graph, reversed_graph;
	vector<bool> used;
	vector<long long> topsort, comp, answer;

	void dfs(long long v) {
		used[v] = true;
		for (long long to : graph[v]) {
			if (!used[to]) {
				dfs(to);
			}
		}
		topsort.push_back(v);
	}

	void dfs2(long long v, long long &color) {
		comp[v] = color;
		for (long long to : reversed_graph[v]) {
			if (comp[to] == -1) {
				dfs2(to, color);
			}
		}
	}

	signed main() {
		// input data
		bool solution = true;
		used.assign(n * 2, false);
		for (long long i = 0; i < n * 2; i++) {
			if (!used[i]) {
				dfs(i);
			}
		}
		ll comp_number = 0;
		comp.assign(n * 2, -1);
		for (long long i = n * 2 - 1; i > -1; i--) {
			if (comp[topp[i]]] == -1) {
				dfs2(i, comp_number);
				comp_number++;
			}
		}
		for (long long i = 0; i < n; i++) {
			if (comp[i] != comp[i + n]) {
				ans = {-1};
				return 0;
			}
		}
		ans = {};
		for (long long i = 0; i < n; i++) {
			if (comp[i] > comp[i + n]) {
				ans.push_back(i);
			} else {
				ans.push_back(i + n);
			}
		}
		// output data
	}

Применения 2-SAT
________________

Есть несколько интересных идей, отражённых в следующих задачах, которые кажутся полезными. Зачастую в задачах на 2-sat важно правильно определить что именно является вершинами нужного графа для 2-sat

.. task::

    Дан граф. Нужно выбрать часть вершин так, чтобы для каждого ребра был отмечен один из концов, и максимальная разница между номерами выбранных вершин была минимальна.
    |
    |
    
    
    Сделаем бинпоиск по ответу. Тогда мы не можем брать вершины с номерами ближе `mid`, но если мы это будем выражать в виде единичных импликаций, их количество может быть до `N^2`, поэтому нужно ввести фиктивные вершины которые будут отвечать за отрезки длиной `N, N/2, N/4...` также как в Дереве Отрезков. Таким образом мы накладываем 2 вида огранчений: на номера и на рёбра, а затем используем 2-sat. 
            
    
    |

.. task::

    Дан граф. Дано множество троек, состоящих из чисел `x, y` и строки `s`, таких что на пути от `x` до `y` количество вершин это длина `s`. Нужно дать каждой вершине букву в соответствие так, чтобы для каждой тройки на пути от `x` к `y` была написана строка `s` в прямом или обратном порядке.
    |
    |
    
    
    Сделаем вершины отвечающие за то, что конкретная строка напечатана и за то, что какая-то буква написана в конкретной вершине. Очевидно, для каждой вершины это не больше двух варинтов, если она есть хотя бы на одном пути, а иначе в неё можно ставить любую букву. Ограничения будут между символами в одной вершине, и между строками и символами, между парами строк вводить ограничения слишком долго.
            
    
    |


