.. highlight:: cpp

Дополнительные замечания
========================

Быстрый ввод-вывод
------------------

Стандартный ввод/вывод через ``iostream`` (т.е. с использованием ``cin``/``cout``) по умолчанию работает 
медленно на больших данных. Если вам надо ввести, допустим, 100000 чисел, то с использованием ``cin`` 
такой ввод будет работать очень долго, скорее всего заметно больше секунды,
и поэтому на большинстве наших задач вы получите time limit. Аналогично если вам надо выводить много данных. Это связано с двумя проблемами.

Во-первых, медленно работает ``endl``.  Поэтому не используйте ``endl`` вообще, используйте ``'\n'``.

.. note ::

    Вывод в ``cout`` буферизуется, т.е. данные не сразу попадают на экран или на диск, а сначала собираются
    в большую строку («буфер»), и только когда их накопится достаточно много, ну или в конце работы программы, попадают на диск или на экран 
    — дело в том, что реальный вывод данных работает медленно, намного быстрее сразу вывести
    строку из допустим 100000 символов, чем 10000 строк по 10 символов — и буферизация как раз это и делает. 
    Но ``endl`` каждый раз сбрасывает буфер, реально выводя данные на экран или на диск, поэтому если вы выводите много чисел через ``endl``, то это будет медленно.

Во-вторых, есть еще проблема синхронизации с ``stdio`` (не буду сейчас подробнее писать, что это значит). Чтобы эту проблему побороть, есть три способа:

- Работать с файлами, а не с клавиатурой/экраном (когда это допустимо). У ``fstream`` таких проблем со скоростью работы нет.
- Использовать для ввода/вывода конструкции в стиле C (``scanf`` и ``printf`` из ``stdio.h``), а не из ``iostream``.
- Написать в самом начале программы две магические строчки (их надо выучить наизусть)::


    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

Лично я вам рекомендую использовать первый (работать с файлами) или последний (с магическими строками) вариант.

Еще раз: есть **две** проблемы: одна с ``endl``, другая с синхронизацией ``stdio`` и ``iostream``. 
Одна решается тем, что вы не используете ``endl``, другая — вот одним из трех описанных выше способов. 
Вам надо решить **обе** проблемы, т.е. и не использовать ``endl``, и как-то разобраться с синхронизацией. 
Типичная ошибка — написать в начале программы этот страшный код с ``sync_with_stdio``, но выводить все равно через 
``endl``. Получите time limit exceeded все равно.

Установка стека
---------------

В популярных компиляторах C++ по умолчанию установлен очень маленький размер стека (т.е. памяти,
выделяемой под все локальные переменные всех функций). Если в вашей программе глубокая рекурсия 
(например, если вы пишете поиск в глубину), то программа может упасть, потому что на каждом уровне рекурсии
функции нужны локальные переменные, и стека может не хватить на все уровни рекурсии.

(То же самое может быть, если вы попробуете объявить очень много переменных — сотни тысяч, а то и больше — в одной функции, без всякой рекурсии,
но это надо очень сильно постараться, например, использовать массивы в стиле С, а не C++. 
Поэтому вы намного чаще с этой проблемой будете сталкиваться именно в рекурсивных решениях.)

В GCC попросить большой размер стека из самой программы невозможно. Поэтому, чтобы ваш код работал на больших данных, 
надо сделать соответствующие настройки компиляции — в командную строку компилятора добавить параметр типа ``-Wl,stack,64000000``. 
Если вы компилируете вручную через командную строку, то указывайте этот параметр. Если компилируете через Code::Blocks, 
то найдите размер стека в настройках компиляции. На олимпиадах вам надо надеяться на то, что в тестирующей системе тоже будет установлен большой стек
(т.е. будет добавлен нужный параметр компиляции); на нормальных олимпиадах жюри это всегда делает
и указывает это в памятке в разделе со строками компиляции.

А вот в Visual Studio можно установить необходимый размер стека прямо из программы примерно следующей конструкцией::

    #pragma comment(linker, "/STACK:64000000")

Число ``64000000`` в обоих примерах выше — это необходимый вам размер стека в байтах (в примерах 64 миллиона байт, т.е. примерно 64 Мб). 
Размер стека можете посчитать в уме исходя из вашей программы (умножьте глубину рекурсии на размер памяти, требуемый на один уровень рекурсии — 
это примерно сколько памяти занимают все переменные на одном уровне, плюс 10-20 байт), а можете и подобрать опытным путем — 
32-64 Мб обычно достаточно. Учитывайте еще, конечно, ограничение по памяти.

Поэтому если вы пишете на MSVS, то всегда явно устанавливайте размер стека. Если пишете на g++ в code::blocks, то для локального запуска настройте 
в настройках code::blocks; и надейтесь, что в тестирующей системе жюри это нормально настроит 
(по-нормальному это должно быть видно в памятке участника). Если пишете на g++ и компилируете из командной строки 
вручную, то добавляйте нужный параметр и, опять-таки, надейтесь на жюри. Если вдруг жюри не настроило стек на g++, 
но при этом предоставляет возможность отправки под MSVS, то добавьте магическую MSVS-строчку и отправляйте под MSVS, даже если вы пишете под g++.


Undefined behavior
------------------

(Это довольно продвинутая тема, для начального изучения не особо нужная, но в целом иметь представление
об undefined behavior надо.)

Неопределенное поведение, undefined behavior, сокращенно UB — это довольно необычная (по сравнению с другими языками)
особенность C++. Смысл в том, что в определенных ситуациях (например, при выходе за пределы массива) 
программа на C++ имеет право делать что угодно — работать правильно, молча выдать неправильный ответ, не выдать ответа вообще, 
упасть с ошибкой, зависнуть, отформатировать жесткий диск и т.д. Стандарт C++ никак не определяет, что должна делать
программа в таком случае, а наоборот, разрешает компиляторам делать такой исполняемый код, какой им удобнее — и, соответственно,
вы не можете никак контролировать, как себя в этой ситуации будет вести программа.

Таких ситуаций довольно много, но в простейших программах вы скорее всего будете встречаться только
с тремя — во-первых, это выход за пределы массива (в том числе строки), во-вторых, это переполнение знаковых целых чисел 
(знаковых — т.е. тех, которые не unsigned), и в-третьих, это попытка два раза изменить одну и ту же переменную в пределах одной и той же команды.

Пример третьего случая — знаменитая запись ``i = i++ + ++i;``. Здесь переменная ``i`` меняется три раза: за счет присваивания,
за счет ``i++`` и за счет ``++i``, при этом язык C++ не указывает, в каком порядке должны производиться эти изменения,
поэтому это undefined behavior.

.. note ::

    Стандарт работает по принципу «что не разрешено — то неопределённое поведение».
    Так что несмотря на то, что в некоторых случаях действительно явно записано, что поведение
    в таком-то случае не определено, часто некоторый случай в стандарте просто не описан.
    Из-за этого до сих пор не существует никакого полного перечня неопределённого поведения,
    хотя подвижки в эту сторону были.
    Если вы любите длинные тексты и крайние случаи, то можете взглянуть `на P1705 <http://wg21.link/P1705>`_ — предложение
    включить в стандарт отдельный хотя бы частичный список UB.

Основное, что надо понимать про UB — это то, что поведение действительно не определено. Компилятор сделает такой исполняемый код, как ему удобнее,
и результат будет зависеть от огромного количества параметров (конкретной версии компилятора и его опций, ОС, в которой работает программа,
процессора, на котором она работает, в конце концов, от того, какие еще программы запущены параллельно с вашей или были запущены до нее),
поэтому пытаться предсказывать результат бессмысленно. Максимум, что можно — попытаться как-то объяснить тот результат,
который таки получится, но и это не всегда. В частности, на вопрос «чему будет равно ``i`` после ``i = i++ + ++i;``»
единственный верный ответ — «это undefined behavior, точка».

То, что я написал выше — это классические объяснение UB, но возможно оно не до конца понятно. Полезно на это посмотреть еще вот с какой стороны.
Когда компилятор компилирует вашу программу, он исходит из некоторых предположений, которые необходимы для того,
чтобы ваша программа работала. Например, он обязательно должен понимать, на каком процессоре будет запущена ваша программа,
ну или хотя бы какие фичи этот процессор будет поддерживать — поэтому если вы скомпилируете программу с одними предположениями
о процессоре, а потом запустите на процессоре, который таких фич не поддерживает, то понятно, что программа может повести себя странно 
— может отработать корректно, может выдать неверный ответ, вылететь и т.д. — ясно, что это не вина компилятора. 

Точно также компилятор исходит из некоторых предположений про вашу программу. Например, он предполагает, что в вашей программе
невозможен выход за пределы массива. Он может даже заметить, что в каком-то конкретном месте возможен выход за пределы массива,
но компилятор понадеется на вас, на программиста — он подумает, что вам как автору программы известно что-то,
за счет чего выхода за пределы массива там никогда не будет (возможно, компилятор недопонял какую-нибудь хитрую логику
в вашей программе, которая гарантирует, что выхода за пределы массива не будет; или может быть просто соответствующие
входные данные просто недопустимы и т.д.). И соответственно компилятор формирует исполняемый код,
предполагая, что выхода за пределы массива не бывает. Ну а тогда если выход все-таки случился, то программа,
как и в случае с неправильным процессором, может вести себя странно, причем нет никаких гарантий на то, как конкретно она себя поведет.
То есть изначально может показаться, что UB — это компилятор специально делает такую подлянку программисту, но нет.
Наоборот, UB — это результат того, что в программе случилось то, чего с точки зрения компилятора никогда не должно быть,
на что компилятор в принципе не рассчитывал.

Иногда кажется, что последствия UB можно легко предсказать. Действительно, ну и пусть в программе выход за пределы массива, например,
когда читаете элемент массива (не записываете данные в память, а читаете, для простоты). Казалось бы, ну и что, там за пределами массива
все равно есть какая-то память, программа просто прочитает какое-то число, которое там записано, и будет с ним работать...
Но нет. Дело еще в том, что современные компиляторы применяют очень серьезные оптимизации. И если компилятор видит,
что он может применить какую-нибудь оптимизацию так, что она будет корректна во всех случаях, кроме тех, когда получается UB,
то компилятор имеет полное право ее применять. И он может наоптимизировать так, что это уже будет не просто чтение памяти
за пределами массива, а что-нибудь совем другое.

Классический пример — следующая программа::

    #include <iostream>

    int table[4] = {2, 4, 6, 8};

    bool exists_in_table(int v)
    {
        for (int i = 0; i <= 4; i++) {
            if (table[i] == v) return true;
        }
        return false;
    }

    int main() {
        for (int i = 0; i < 10; i++) {
            std::cout << i << " " << exists_in_table(i) << std::endl;
        }
        return 0;
    }

(Здесь конструкция ``int table[4] = {2, 4, 6, 8};`` — это массив в стиле C. Не надо его использовать в реальных программах,
но тут для иллюстрации UB он нужен. С vector такого простого примера не получается.)

Функция ``exists_in_table`` пытается проверить, есть ли число ``v`` в массиве.
Но в функции ошибка: выход за пределы массива при ``i==4``, т.е. функция сравнивает ``v`` с числами, которые есть в массиве,
и плюс делает одно лишнее сравнение с числом за пределами массива.
Казалось бы, как такая функция будет себя вести? Она, понятно, вернет ``true`` для чисел 2, 4, 6, 8, ну и казалось бы
еще вернет ``true`` для какого-нибудь еще числа, которому повезло лежать в памяти сразу после массива,
а для остальных чисел вернет ``false``.
Но нет! Если скомпилировать программу с включенными оптимизациями, то функция будет возвращать ``true`` для любого вообще числа
(ну и программа на экран выведет столбец единичек). Потому что компилятор увидел, что функция может или вернуть ``true`` (если ``v`` равно 2, 4, 6 или 8),
или в функции случится UB. Т.е. на всех корректных путях функция возвращает ``true``. А тогда зачем вообще делать какие-то проверки,
давайте возвращать ``true`` всегда...

В общем, тема UB тесно связана с темой оптимизаций: компилятор делает оптимизации в предположении что UB невозможно,
а если потом оказывается, что UB все-таки случится, то оптимизации могут повести себя совершенно непредсказуемо.

Ну и наконец — я выше писал, что в результате UB программа может отформатировать ваш жесткий диск.
Конечно, просто так такого не случится. Но чисто теоретически это возможно, хотя и надо специально очень тщательно постараться.
Конечно, если задаться такой целью, то возможно написать специальную хитрую программу, которая в результате UB отформатирует жесткий диск (хотя и не очень понятно, зачем так стараться
— ясно, что намеренно отформатировать жесткий диск из программы можно и без всякого UB :) ).
Но что хуже — если ваша программа принимает какие-то входные данные (как обычно и бывает), и в программе есть UB,
то чисто теоретически злобный хакер может подобрать специальные хитрые входные данные, в результате которых UB сработает так,
что программа отформатирует ваш жесткий диск. И это уже достаточно реально; конкретно форматировать жесткий диск современные хакеры вряд ли будут,
а вот утечка персональных данных из-за UB — это вполне бывает (в качестве простейшего, но широко известного, примера, см. уязвимость Heartbleed).

У меня есть `видео про undefined behavior <https://www.youtube.com/watch?v=P3Ip3WNxPVg>`_, если хотите, можете посмотреть его.